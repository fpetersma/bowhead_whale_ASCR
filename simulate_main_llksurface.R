# ============================================================================ #
#                 Simulate data for performance testing                        #
# ============================================================================ #

## Load required libraries
library("readr")
library("matrixStats")
library("truncnorm")
library("plotly")

## Define some constants
seed <- 707706
# sample_size <- 30
min_no_detections <- 2
# max_depth <- 150
trunc_level <- 75

SINGLE_SL <- TRUE
WITH_NOISE <- FALSE

source("Scripts/Bowhead Whales/hidden_functions.R")
source("Scripts/Bowhead Whales/plotDensity.R")
source("Scripts/Bowhead Whales/simulateData.R")
source("Scripts/Bowhead Whales/llkSurface.R")
source("Scripts/Bowhead Whales/llkParallelSmooth.R")

# if (SINGLE_SL) {
#   source("Scripts/Bowhead Whales/bwASCRSingleSL.R")
#   source("Scripts/Bowhead Whales/llkSNRSingleSL.R")
#   source("Scripts/Bowhead Whales/llkRLSingleSL.R")
# } else {
#   source("Scripts/Bowhead Whales/bwASCR.R")
#   source("Scripts/Bowhead Whales/llkSNR.R")
# }

mesh_file <- "Data/grid_adaptive_levels=1_maxD2C=100k_maxD2A=100k_area=21785.36_n=1163.csv"

## Load a fine grid of the study area
mesh <- read.csv(mesh_file)
cov_density <- mesh
cov_density$depth <- abs(cov_density$depth) # make depth positive 
cov_density$depth[cov_density$depth == 0] <- 0.01
cov_density[["depth2"]] <-  cov_density$depth ^ 2
cov_density[["logdepth"]] <- log(cov_density$depth)
cov_density[["logdepth2"]] <- cov_density$logdepth ^ 2
cov_density[["distance_to_coast2"]] <- cov_density$distance_to_coast ^ 2

# # Set the area parameter DIFFERENT NOW AS AREA IS VARIABLE
# A <- 8.774550 # km^2
# cov_density$area <- 56.21183

## Load the detector location data
DASAR <- as.data.frame(read_tsv("Data/DASARs.txt"))
DASAR$long <- -abs(DASAR$long) # Turn longitude from westing to easting (more common)
detectors <- DASAR[DASAR$year == 2010 & DASAR$site == 5, c("long", "lat")] 

# Define the density function
f_density <- D ~ 1
# f_density <- D ~ distance_to_coast + distance_to_coast2
# f_density <- D ~ depth + depth2

# set det function!
det_function <- "simple"
# det_function<- "probit"
# det_function <- "half-normal"
# det_function <- "logit"
# det_function <- "janoschek"

## Set all parameters on the real scale. Only density is on the log scale
# Parameters for density function
par_dens <- c("(Intercept)" = -1.5)
# par_dens <- c("(Intercept)" = -2.5, "distance_to_coast" = 3, "distance_to_coast2" = -3)
# par_dens <- c("(Intercept)" = -3, "depth" = 0.5, "depth2" = -2)
# par_dens <- c("(Intercept)" = -2.2, "depth" = -1.8, "depth2" = 1.8)

if (det_function == "janoschek") {
  # Detection function parameters
  par_det <- c(U = 0.8,  # should be in (0, 1]
               B = 1.5,  # should be in (0, Inf)
               Q = 2.8)  # should be in (1, Inf)
} else if (det_function == "logit" | det_function == "probit") {
  # Detection function parameters
  par_det <- c(U = 0.7,  # should be in (0, 1]
               B = 20,   # should be in (0, Inf)
               Q = 5)    # should be in (0, Inf)
} else if (det_function == "simple") {
  # Detection function parameters
  par_det <- c(g0 = 0.7)
}else {
  par_det <- c(g0 = 0.7,
               sigma = 15000)
}

# Distribution of mean noise level per call
par_noise <- c(mu = 65,
               sd = 5,
               lower = 0,
               upper = Inf)

# Source level distribution 
par_sl <- c(mu = 140,
            sd = 5,
            lower = 0,
            upper = Inf)

# Received level parameters
par_rl <- c(beta = 15,
            sigma = 3)

# Bearing distribution
par_bear <- c(kappa = 5000)

par <- list(par_dens = par_dens,
            par_det = par_det,
            par_noise = par_noise,
            par_sl = par_sl,
            par_rl = par_rl,
            par_bear = par_bear)

# Set seed
set.seed(seed)

################ Run the simulation using simulateData.R #######################
dat_sim <- simulateData(par = par, f_density = f_density, cov_density = cov_density,
                        min_no_detections = min_no_detections, 
                        SINGLE_SL = SINGLE_SL, WITH_NOISE = WITH_NOISE,
                        detectors = detectors, det_function = det_function,
                        trunc_level = trunc_level)

################# Fit ASCR model to the simulated data #########################
# sample_size <- nrow(dat_sim$det_hist) # 30
# index <- #1:nrow(dat_sim$det_hist) #sample(1:nrow(dat_sim$det_hist), sample_size)

det_hist <- dat_sim$det_hist#[index, ]
bearings_hist <- dat_sim$bearings#[index, ]
noise_call <- dat_sim$noise_call#[index, ]
noise_random <- dat_sim$noise_random[1:100, ]
received_levels_hist <- dat_sim$received_levels#[index, ]

DASAR <- as.data.frame(read_tsv("Data/DASARs.txt"))

mesh_file <- "Data/grid_adaptive_levels=1_maxD2C=100k_maxD2A=100k_area=21785.36_n=1163.csv"

mesh <- read.csv(mesh_file)

########################### Create mask ########################################
cov_density <- mesh
cov_density$depth <- abs(cov_density$depth) # make depth positive 
cov_density$depth[cov_density$depth == 0] <- 0.01
cov_density[["depth2"]] <-  cov_density$depth ^ 2
cov_density[["logdepth"]] <- log(cov_density$depth)
cov_density[["logdepth2"]] <- cov_density$logdepth ^ 2
cov_density[["distance_to_coast2"]] <- cov_density$distance_to_coast ^ 2

######################### Create detectors #####################################

DASAR$long <- -DASAR$long # Turn longitude from westing to easting (more common)
detectors <-  DASAR[DASAR$year == 2010 & DASAR$site == 5, c("long", "lat")]

# Density formula specification
f_density <- D ~ 1 #s(dist_to_coast, k = 3, fx = TRUE) # + depth
# f_density <- D ~ distance_to_coast + distance_to_coast2

# Define some constants
min_no_detections <- 2

# Set the source level integration increments and the grid areas
A_s <- 3
A_x <- subset(mesh, select = c(area, long, lat))
# A_x$area <- 56.21183

det_function <- "simple"
# det_function <- "probit"
# det_function <- "janoschek"
# det_function <- "logit"
# det_function <- "half-normal"

dat <- list(det_hist = det_hist,
            detectors = detectors,
            cov_density = cov_density,
            received_levels = received_levels_hist,
            noise_call = noise_call,
            noise_random = noise_random,
            source_levels = seq(from = 120 + (A_s / 2), to = 180, by = A_s),
            A_x = A_x,
            A_s = A_s,
            f_density = f_density,
            det_function = det_function,
            bearings = bearings_hist,
            min_no_detections = min_no_detections,
            SINGLE_SL = SINGLE_SL,
            WITH_NOISE = WITH_NOISE,
            trunc_level = trunc_level)


# Start values for detection function
if(det_function == "janoschek") {
  par_det_start <- c(U = log(0.8 / (1 - 0.8)), # should be in (0, 1]
                     B = log(1.5), # should be in (0, Inf)
                     Q = log(2.8 - 1)) # should be in (1, Inf)
} else if (det_function == "logit" | det_function == "probit") {
  # Detection function parameters
  par_det_start <- c(U = log(0.7 / (1 - 0.7)), # should be in (0, 1]
                     B = log(20), # should be in (0, Inf)
                     Q = log(5)) # should be in (0, Inf)
} else if (det_function == "simple") {
  # Detection function parameters
  par_det_start <- c(g0 = log(0.7 / (1 - 0.7)))
} else {
  par_det_start <- c(g0 = log(0.8 / (1 - 0.8)),
                     sigma = log(15000))
}

# Start values for density function
par_dens_start <- c("(Intercept)" = -1.5)
# par_dens_start <- c("(Intercept)" = -2.5, "distance_to_coast" = 3, "distance_to_coast2" = -3)
# par_dens_start <- c("(Intercept)" = -3, "depth" = 0.5, "depth2" = -2)

# Start values for received level
par_rl_start <- c(beta_r = log(15),
                  sd_r = log(3)
                  )

# Start values for source level
par_sl_start <- c(mu_s = log(140), # identity
                  sd_s = log(5)
                  ) # log

# Start values for bearing
par_bear_start <- c(kappa = log(5000)) # log


par_fix <- list(par_det = par_det_start,
                par_bear = par_bear_start,
                par_rl = par_rl_start,
                par_sl = par_sl_start,
                par_dens = par_dens_start)

par_flex <- list(mu_s = log(136:144), 
                 beta_r = log(c(13, 13.5, 14, 14.5, 15, 15.5, 16, 16.5, 17)))


######################## Get likelihood surfaces ##########################
a <- llkSurface(par_fix = par_fix, 
                 par_flex = par_flex, 
                 dat = dat, 
                 USE_BEARINGS = TRUE)

# volcano is a numeric matrix that ships with R
fig_a <- plot_ly(z = ~ a, y = ~ colnames(a), x = ~ rownames(a))
fig_a <- fig_a %>% add_surface()

fig_a

# More zoomed in
par_flex <- list(mu_s = log(seq(from = 139, to = 141, by = 0.2)), 
                 beta_r = log(seq(from = 14.4, to = 15.6, by = 0.1)))

b <- llkSurface(par_fix = par_fix, 
                par_flex = par_flex, 
                dat = dat, 
                USE_BEARINGS = TRUE)

# volcano is a numeric matrix that ships with R
fig_b <- plot_ly(z = ~ b, y = ~ colnames(b), x = ~ rownames(b))
fig_b <- fig_b %>% add_surface()

fig_b

# More 
# Start values for received level
par_rl_start <- c(# beta_r = log(15),
                  # sd_r = log(3)
)

# Start values for source level
par_sl_start <- c(mu_s = log(140), # identity
                  sd_s = log(5)
) # log

# Start values for bearing
par_bear_start <- c(kappa = log(5000)) # log


par_fix <- list(par_det = par_det_start,
                par_bear = par_bear_start,
                par_rl = par_rl_start,
                par_sl = par_sl_start,
                par_dens = par_dens_start)

par_flex <- list(sd_r = log(seq(from = 2.5, to = 3.5, by = 0.1)), 
                 beta_r = log(c(13, 13.5, 14, 14.5, 15, 15.5, 16, 16.5, 17)))

c <- llkSurface(par_fix = par_fix, 
                par_flex = par_flex, 
                dat = dat, 
                USE_BEARINGS = TRUE)

fig_c <- plot_ly(z = ~ c, y = ~ colnames(c), x = ~ rownames(c))
fig_c <- fig_c %>% add_surface()

fig_c # problem seems to be mainly in beta_r, which has low identifiability (increasig grid might solve this?)


# NUMBAH 4

par_det_start <- c(#g0 = log(0.7 / (1 - 0.7))
  )

# Start values for density function
par_dens_start <- c("(Intercept)" = -1.5)
# par_dens_start <- c("(Intercept)" = -2.5, "distance_to_coast" = 3, "distance_to_coast2" = -3)
# par_dens_start <- c("(Intercept)" = -3, "depth" = 0.5, "depth2" = -2)

# Start values for received level
par_rl_start <- c(beta_r = log(15),
                  sd_r = log(3)
)

# Start values for source level
par_sl_start <- c(#mu_s = log(140), # identity
                  sd_s = log(5)
) # log

# Start values for bearing
par_bear_start <- c(kappa = log(5000)) # log


par_fix <- list(par_det = par_det_start,
                par_bear = par_bear_start,
                par_rl = par_rl_start,
                par_sl = par_sl_start,
                par_dens = par_dens_start)

par_flex <- list(g0 = log(seq(from=0.6, to=0.8, by=0.02) / (1 - seq(from=0.6, to=0.8, by=0.02))), 
                 mu_s = log(seq(from = 139, to = 141, by = 0.2)))

d <- llkSurface(par_fix = par_fix, 
                par_flex = par_flex, 
                dat = dat, 
                USE_BEARINGS = TRUE)

fig_d <- plot_ly(z = ~ d, 
                 y = ~ exp(as.numeric(colnames(d))) / (1 + exp(as.numeric(colnames(d)))), 
                 x = ~  exp(as.numeric(rownames(d))))
fig_d <- fig_d %>% add_surface()

fig_d
